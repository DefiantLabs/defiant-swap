package cmd

import (
	"bufio"
	"errors"
	"fmt"
	"os"

	"github.com/KyleMoser/OsmosisArbitrageCLI/query"
	"github.com/cosmos/cosmos-sdk/client"
	"github.com/cosmos/cosmos-sdk/client/flags"
	"github.com/cosmos/cosmos-sdk/client/input"
	"github.com/cosmos/cosmos-sdk/client/tx"
	"github.com/cosmos/cosmos-sdk/types"
	"github.com/spf13/cobra"
)

var genTokenUrl = "http://arb.defiantlabs.net:8080/api/token"
var simulateSwapUrl = "http://arb.defiantlabs.net:8080/api/secured/estimateswap"
var defiantRpc = "http://arb.defiantlabs.net:26657"
var defaultChain = "osmosis-1"

var swapCmd = &cobra.Command{
	Use:   "swap",
	Short: "Performs a swap on Osmosis, optimizing rates for users",
	Long:  `Optimizes swaps by capturing arbitrage revenue that would normally go to bots. This is a free service provided by Defiant Labs`,
	RunE: func(cmd *cobra.Command, args []string) error {
		clientCtx, err := client.GetClientTxContext(cmd)
		flagSet := cmd.Flags()

		clientCtx = clientCtx.WithNodeURI(defiantRpc)
		clientCtx = clientCtx.WithChainID(defiantRpc)
		rpcProvider := defiantRpc
		chain := defaultChain

		node, nErr := flagSet.GetString("node")
		if nErr != nil && node != "" {
			rpcProvider = node
		}

		chain_u, chainErr := flagSet.GetString("chain-id")
		if chainErr != nil && chain_u != "" {
			chain = chain_u
		}
		clientCtx = clientCtx.WithChainID(chain)

		//RPC connection endpoint
		rpcClient, rpcErr := client.NewClientFromNode(rpcProvider)
		cobra.CheckErr(rpcErr)
		clientCtx = clientCtx.WithClient(rpcClient)

		if err != nil {
			return err
		}

		address := clientCtx.GetFromAddress().String()
		fmt.Printf("Address: %s\n", address)
		jwt := query.JWT{}
		jwtReq := query.JWTRequest{Address: address}

		queryParams := map[string]string{}
		if hasPartnerCode {
			secret, err := GetPwd("Enter partner secret:")
			if err != nil {
				return err
			}
			queryParams["partnerSecret"] = secret
		}

		//Make a request to the server to authenticate us. The server will return a JWT.
		httpStatus, err := query.PostJson(genTokenUrl, &jwtReq, &jwt, queryParams, nil)

		if err != nil {
			return err
		} else if httpStatus != 200 {
			if jwt.Error != "" {
				return fmt.Errorf("HTTP Status %d. Reason: %s", httpStatus, jwt.Error)
			} else {
				return fmt.Errorf("HTTP Status %d", httpStatus)
			}
		}

		cobra.CheckErr(err)
		symbolIn, _ := flagSet.GetString("in")
		symbolOut, _ := flagSet.GetString("out")
		amountIn, _ := flagSet.GetString("amount-in")
		amountOut, _ := flagSet.GetString("min-amount-out")
		arbitrageWallet, _ := flagSet.GetString("arb-wallet")

		simSwapReq := &query.SimulatedSwapRequest{
			TokenInSymbol:        symbolIn,
			TokenOutSymbol:       symbolOut,
			TokenInAmount:        amountIn,
			TokenOutMinAmount:    amountOut,
			SkipWalletFundsCheck: !verifyFunds,
			UserWallet:           address,
			ArbitrageWallet:      arbitrageWallet,
		}
		result := &query.SimulatedSwapResult{}
		httpStatus, err = query.PostJson(simulateSwapUrl, simSwapReq, &result, nil, &jwt)
		if result.Error != "" {
			return errors.New(result.Error)
		} else if httpStatus != 200 {
			return fmt.Errorf("issue with request, HTTP Status %d", httpStatus)
		}

		cobra.CheckErr(err)
		fmt.Printf("Your swap would trade %s %s for %s using Osmosis pool(s) %s.\n", amountIn, symbolIn,
			result.SimulatedUserSwap.AmountOutHumanReadable, result.SimulatedUserSwap.Pools)

		if result.HasArbitrageOpportunity {
			fmt.Printf("In addition, your swap would earn %s through arbitrage that would otherwise go to bots.\n",
				result.ArbitrageSwap.EstimatedProfitHumanReadable)
			fmt.Printf("Arbitrage trade (auto-generated by Defiant Labs): %s %s through pool(s) %s, expected result: %s out.\n",
				result.ArbitrageSwap.SimulatedSwap.TokenIn.Amount.String(),
				result.ArbitrageSwap.SimulatedSwap.TokenIn.Denom,
				result.ArbitrageSwap.SimulatedSwap.Pools,
				result.ArbitrageSwap.SimulatedSwap.TokenOutAmount.String(),
			)
		}

		err = Confirm("Proceed with the swap?")
		cobra.CheckErr(err)

		if err == nil {
			msgs := []types.Msg{}

			msgUserSwap, err := query.BuildSwapExactAmountIn(clientCtx, result.SimulatedUserSwap.TokenIn, result.SimulatedUserSwap.TokenOutMinAmount, result.SimulatedUserSwap.Routes)
			cobra.CheckErr(err)
			msgs = append(msgs, msgUserSwap)
			txGas := query.GetGasFee(len(result.SimulatedUserSwap.Routes))

			fmt.Printf("Performing user's swap. Token in: %s. Minimum amount out: %s. Pool(s) %s.\n",
				result.SimulatedUserSwap.TokenIn,
				result.SimulatedUserSwap.TokenOutMinAmount,
				result.SimulatedUserSwap.Pools)

			if result.HasArbitrageOpportunity {
				arbSwap, err := query.BuildSwapExactAmountIn(clientCtx, result.ArbitrageSwap.SimulatedSwap.TokenIn,
					result.ArbitrageSwap.SimulatedSwap.TokenOutMinAmount, result.ArbitrageSwap.SimulatedSwap.Routes)
				cobra.CheckErr(err)
				msgs = append(msgs, arbSwap)
				txGas = txGas + query.GetGasFee(len(result.ArbitrageSwap.SimulatedSwap.Routes))

				fmt.Printf("Performing arbitrage swap. Token in: %s. Minimum amount out: %s. Pool(s) %s.\n",
					result.ArbitrageSwap.SimulatedSwap.TokenIn,
					result.ArbitrageSwap.SimulatedSwap.TokenOutMinAmount,
					result.ArbitrageSwap.SimulatedSwap.Pools)
			}

			txf := query.BuildTxFactory(&clientCtx, txGas)
			txf, txfErr := query.PrepareFactory(clientCtx, clientCtx.GetFromName(), txf)
			cobra.CheckErr(txfErr)

			txBuilder, err := tx.BuildUnsignedTx(txf, msgs...)
			cobra.CheckErr(err)

			txBuilder.SetFeeGranter(clientCtx.GetFeeGranterAddress())
			err = tx.Sign(txf, clientCtx.GetFromName(), txBuilder, true)
			cobra.CheckErr(err)

			txBytes, err := clientCtx.TxConfig.TxEncoder()(txBuilder.GetTx())
			cobra.CheckErr(err)

			tx1resp, err := clientCtx.BroadcastTxSync(txBytes)
			cobra.CheckErr(err)
			fmt.Printf("TX result code: %d", tx1resp.Code)
		}

		return err
	},
}

var (
	arbitrageWallet string //wallet to use for arbs. defaults to user wallet.
	tokenFrom       string //token to trade from
	tokenTo         string //token to trade to
	amountIn        string //amount you want to trade
	amountOut       string //minimum amount you'll receive
	verifyFunds     bool
	hasPartnerCode  bool
)

func init() {
	swapCmd.Flags().StringVar(&arbitrageWallet, "arb-wallet", "", "address to use for arbitrage")
	swapCmd.Flags().StringVar(&tokenFrom, "in", "", "The token you want to trade")
	swapCmd.Flags().StringVar(&tokenTo, "out", "", "The token you want to receive")
	swapCmd.Flags().StringVar(&amountIn, "amount-in", "", "The amount to trade (in the base amount). Ex: if the token is OSMO you might put --amount-in 101.5")
	swapCmd.Flags().StringVar(&amountOut, "min-amount-out", "", "The minimum amount of the token you want to receive, format is the same as amount-in")
	swapCmd.Flags().BoolVar(&verifyFunds, "verify-funds", true, "Check that the user's wallet contains enough funds for the trade. Turn off to simulate regardless of funds.")
	swapCmd.Flags().BoolVar(&hasPartnerCode, "partner", false, "Will prompt for partner secret if --partner=true. Unlocks unlimited API requests.")

	swapCmd.MarkFlagRequired("in")
	swapCmd.MarkFlagRequired("out")
	swapCmd.MarkFlagRequired("amount-in")
	swapCmd.MarkFlagRequired("min-amount-out")
	flags.AddTxFlagsToCmd(swapCmd)
}

func Confirm(prompt string) error {
	buf := bufio.NewReader(os.Stdin)
	ok, err := input.GetConfirmation(prompt, buf, os.Stderr)

	if err != nil || !ok {
		//_, _ = fmt.Fprintf(os.Stderr, "%s\n", "cancelled transaction")
		return errors.New("cancelled transaction")
	}

	return nil
}

func GetPwd(prompt string) (string, error) {
	buf := bufio.NewReader(os.Stdin)
	pass, err := input.GetPassword(prompt, buf)

	if err != nil {
		return "", errors.New("cancelled transaction")
	}

	return pass, nil
}
